<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automated Imitation Learning Pipeline</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f7f9;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        h1 {
            color: #2c3e50;
        }
        
        .container {
            display: flex;
            gap: 30px;
        }
        
        .main-column {
            flex: 1;
            max-width: 900px;
            margin: 0 auto;
        }
        
        .side-column {
            flex: 2;
        }
        
        .card {
            background-color: white;
            border-radius: 8px;
            padding: 25px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input[type="text"],
        input[type="number"],
        input[type="file"],
        textarea,
        select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        textarea {
            resize: vertical;
            min-height: 100px;
            font-family: monospace;
        }
        
        .btn {
            display: inline-block;
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .btn:hover {
            background-color: #2980b9;
        }
        
        .btn-success {
            background-color: #2ecc71;
        }
        
        .btn-success:hover {
            background-color: #27ae60;
        }
        
        .btn-secondary {
            background-color: #95a5a6;
        }
        
        .btn-secondary:hover {
            background-color: #7f8c8d;
        }
        
        .btn-block {
            display: block;
            width: 100%;
        }
        
        .image-preview {
            max-width: 100%;
            margin-top: 15px;
            border-radius: 4px;
        }
        
        .step-container {
            position: relative;
            margin-bottom: 40px;
        }
        
        .step-number {
            position: absolute;
            top: -15px;
            left: -15px;
            width: 30px;
            height: 30px;
            background-color: #3498db;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 1rem;
            border-bottom: 1px solid #ddd;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            margin-right: 2px;
        }
        
        .tab.active {
            background-color: #fff;
            border: 1px solid #ddd;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .status-message {
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            display: none;
        }
        
        .status-message.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status-message.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status-message.info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        
        tr:hover {
            background-color: #f5f5f5;
        }
        
        pre {
            background: #f8f8f8;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        
        code {
            font-family: monospace;
        }
        
        .detection-result {
            border-top: 1px solid #ddd;
            margin-top: 20px;
            padding-top: 20px;
            display: none;
        }
        
        .json-display {
            background-color: #f8f8f8;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
            overflow-x: auto;
        }
        
        .detected-objects {
            margin-top: 10px;
        }
        
        .detected-object {
            display: inline-block;
            background-color: #e3f2fd;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 20px;
            cursor: pointer;
        }
        
        .actions-list {
            margin-top: 5px;
            margin-bottom: 15px;
            padding-left: 20px;
        }
        
        .edit-json-btn {
            margin-top: 10px;
            font-size: 12px;
        }
        
        .dataset-mapping {
            margin-top: 20px;
            margin-bottom: 20px;
        }
        
        .dataset-item {
            background-color: #f1f8e9;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 5px;
            border-left: 4px solid #7cb342;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .dataset-name {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
            color: #2e7d32;
        }
        
        .dataset-desc {
            margin-bottom: 12px;
            line-height: 1.4;
            color: #555;
            font-size: 14px;
        }
        
        .dataset-matches {
            margin-left: 0;
            margin-top: 10px;
            padding: 8px;
            background-color: #f5f5f5;
            border-radius: 4px;
        }
        
        .matches-header {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
            color: #555;
        }
        
        .match-item {
            background-color: #e3f2fd;
            display: inline-block;
            padding: 4px 10px;
            margin: 3px;
            border-radius: 15px;
            font-size: 13px;
            border: 1px solid #bbdefb;
        }
        
        .progress-container {
            margin: 20px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #f3f3f3;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background-color: #4caf50;
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .training-info {
            margin-top: 10px;
        }
        
        #trainingProgressText {
            text-align: right;
            font-size: 14px;
            margin-top: 5px;
        }
        
        #trainingSteps {
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        /* Dataset selection styles */
        .dataset-selection-list {
            margin-top: 15px;
            margin-bottom: 15px;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
        }
        
        .dataset-checkbox-item {
            margin-bottom: 8px;
            padding: 8px;
            background-color: #f8f9fa;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .dataset-checkbox-item:hover {
            background-color: #e9ecef;
        }
        
        .dataset-checkbox-item label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        .dataset-checkbox-item input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
        }
        
        .dataset-description {
            font-size: 13px;
            color: #555;
            margin-top: 5px;
            margin-left: 25px;
        }
        
        .dataset-selection-actions {
            margin-bottom: 15px;
        }
        
        #selectAllDatasetsBtn, #deselectAllDatasetsBtn {
            margin-right: 10px;
            font-size: 13px;
            padding: 5px 10px;
        }
        
        #startTrainingBtn {
            margin-top: 15px;
            margin-bottom: 15px;
            display: block;
            width: 100%;
            padding: 12px;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        #startTrainingBtn:hover {
            background-color: #218838;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        #startTrainingBtn:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            opacity: 0.65;
            transform: none;
            box-shadow: none;
        }
        
        /* Model naming styles */
        .input-group {
            display: flex;
            width: 100%;
        }
        
        .input-group input {
            flex: 1;
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }
        
        .input-group button {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
            margin-left: -1px;
            font-size: 12px;
            padding: 10px 12px;
        }
        
        .form-text {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        
        /* Add these CSS styles after the existing styles */
        .evaluation-metrics {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        
        .metric-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        
        .metric-row:last-child {
            border-bottom: none;
        }
        
        .metric-label {
            font-weight: bold;
            color: #555;
        }
        
        .metric-value {
            font-size: 16px;
            font-weight: 600;
            color: #28a745;
        }
        
        .trajectory-vis {
            margin-top: 20px;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
            min-height: 300px;
            background-color: #f8f9fa;
        }
        
        .evaluation-history-card {
            margin-top: 20px;
        }
        
        .evaluation-info {
            margin-top: 10px;
        }
        
        #evaluationSteps {
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .trajectory-path {
            stroke: #3498db;
            stroke-width: 2;
            fill: none;
        }
        
        .trajectory-start {
            fill: green;
        }
        
        .trajectory-end {
            fill: red;
        }
        
        .trajectory-success {
            stroke: #2ecc71;
        }
        
        .trajectory-failure {
            stroke: #e74c3c;
        }
        
        /* Benchmark Analysis Styles */
        .checkbox-group {
            margin: 10px 0;
        }
        
        .checkbox-group label {
            display: inline-block;
            margin-right: 20px;
            font-weight: normal;
        }
        
        .checkbox-group input[type="checkbox"] {
            margin-right: 5px;
        }
        
        .benchmark-chart-container {
            margin: 15px 0;
            padding: 10px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 5px;
            text-align: center;
        }
        
        .benchmark-chart {
            max-width: 100%;
            height: auto;
            max-height: 400px;
        }
        
        .benchmark-metrics, .benchmark-radar, .benchmark-summary {
            margin-bottom: 25px;
        }
        
        .benchmark-summary {
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
        
        #benchmarkSummaryText {
            line-height: 1.6;
        }
        
        /* Training Configuration Styles */
        .training-config {
            margin: 15px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #e9ecef;
        }
        
        .training-config h4 {
            margin-bottom: 15px;
            color: #495057;
            font-weight: 600;
        }
        
        .training-config .form-group {
            margin-bottom: 15px;
        }
        
        .training-config label {
            font-weight: 500;
            color: #495057;
        }
        
        .training-config .text-muted {
            font-size: 12px;
            margin-top: 5px;
            display: block;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Automated Imitation Learning Pipeline</h1>
    </div>
    
    <div class="container">
        <div class="main-column">
            <div class="card step-container">
                <div class="step-number">1</div>
                <h2>Upload Image</h2>
                <form id="uploadForm" enctype="multipart/form-data">
                    <div class="form-group">
                        <label for="imageInput">Choose an image:</label>
                        <input type="file" id="imageInput" name="image" accept="image/*">
                    </div>
                    <button type="submit" class="btn">Upload Image</button>
                </form>
                <div id="imagePreviewContainer" style="display: none;">
                    <h3>Uploaded Image:</h3>
                    <img id="imagePreview" class="image-preview" src="" alt="Uploaded image preview">
                </div>
                <div class="loader" id="uploadLoader"></div>
                <div class="status-message" id="uploadStatus"></div>
            </div>
            
            <div class="card step-container">
                <div class="step-number">2</div>
                <h2>Detect Objects & Actions</h2>
                
                <!-- Add the missing customPrompt input field -->
                <div class="form-group">
                    <label for="customPrompt">Custom Prompt (optional):</label>
                    <textarea id="customPrompt" class="form-control" rows="2" placeholder="Enter custom instructions for object detection"></textarea>
                    <small class="text-muted">Leave blank to use default prompt</small>
                </div>
                
                <button id="detectBtn" class="btn btn-lg detect-btn" disabled>Detect Objects & Actions</button>
                
                <div class="detection-result" id="detectionResult" style="display: none;">
                    <h3>Detection Results:</h3>
                    <div id="detectedObjectsContainer" class="detected-objects">
                        <h4>Detected Objects and Actions:</h4>
                        <div id="detectedObjectsList"></div>
                    </div>
                    
                    <div id="datasetMappingContainer" class="dataset-mapping">
                        <h4>Applicable LeRobot Datasets:</h4>
                        <p>Select the datasets you want to include for training:</p>
                        <div id="datasetSelectionList" class="dataset-selection-list"></div>
                        <button id="selectAllDatasetsBtn" class="btn btn-secondary">Select All</button>
                        <button id="deselectAllDatasetsBtn" class="btn btn-secondary">Deselect All</button>
                    </div>
                    
                    <!-- Training Configuration Section -->
                    <div class="training-config">
                        <h4>Training Configuration:</h4>
                        <div class="form-group">
                            <label for="sampleLimit">Sample Limit:</label>
                            <input type="number" id="sampleLimit" class="form-control" value="10000" min="1000" max="100000" step="1000">
                            <small class="text-muted">Maximum number of samples to use for training</small>
                        </div>
                        <div class="form-group">
                            <label for="numEpochs">Number of Epochs:</label>
                            <input type="number" id="numEpochs" class="form-control" value="50" min="10" max="200" step="5">
                            <small class="text-muted">Number of training epochs to run</small>
                        </div>
                    </div>
                    
                    <button id="startTrainingBtn" class="btn btn-success btn-lg" disabled>Start Training Policy</button>
                    <button id="editJsonBtn" class="btn btn-secondary edit-json-btn">Edit JSON</button>
                    <div class="form-group" id="jsonEditorContainer" style="display: none;">
                        <label for="objectsActionsJson">Edit Objects and Actions (JSON):</label>
                        <textarea id="objectsActionsJson" rows="10"></textarea>
                        <button id="updateJsonBtn" class="btn btn-secondary">Update</button>
                    </div>
                </div>
                <div class="loader" id="detectLoader"></div>
                <div class="status-message" id="detectStatus"></div>
                
                <!-- Training Status Section -->
                <div id="trainingStatusContainer" style="display: none;">
                    <h3>Training Status:</h3>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress" id="trainingProgress"></div>
                        </div>
                        <div id="trainingProgressText">0%</div>
                    </div>
                    <div class="training-info">
                        <div id="trainingSteps"></div>
                        <div id="trainingMessage"></div>
                    </div>
                    <div class="form-group">
                        <label for="modelName">Model Name:</label>
                        <input type="text" id="modelName" class="form-control" value="robot_policy">
                        <button id="generateNameBtn" class="btn btn-secondary btn-sm">Generate Name</button>
                    </div>
                </div>
                <div class="loader" id="trainingLoader"></div>
                <div class="status-message" id="trainingStatus"></div>
            </div>
            
            <div class="card step-container">
                <div class="step-number">3</div>
                <h2>Evaluate Policy</h2>
                <div class="form-group">
                    <label for="evaluateModelSelect">Select Model:</label>
                    <select id="evaluateModelSelect" class="form-control">
                        <option value="">Select a model to evaluate</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="numEvaluationEpisodes">Number of Episodes:</label>
                    <input type="number" id="numEvaluationEpisodes" class="form-control" value="3" min="1" max="10">
                    <small class="text-muted">More episodes give more accurate results but take longer</small>
                </div>
                <button id="startEvaluationBtn" class="btn btn-primary btn-lg">Start Evaluation</button>
                
                <div id="evaluationStatusContainer" style="display: none;">
                    <h3>Evaluation Status:</h3>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress" id="evaluationProgress"></div>
                        </div>
                        <div id="evaluationProgressText">0%</div>
                    </div>
                    <div class="evaluation-info">
                        <div id="evaluationSteps"></div>
                        <div id="evaluationMessage"></div>
                    </div>
                </div>
                
                <div id="evaluationResultsContainer" style="display: none;">
                    <h3>Evaluation Results:</h3>
                    <div class="evaluation-metrics">
                        <div class="metric-row">
                            <div class="metric-label">Success Rate:</div>
                            <div class="metric-value" id="successRateValue">0%</div>
                        </div>
                        <div class="metric-row">
                            <div class="metric-label">Average Reward:</div>
                            <div class="metric-value" id="avgRewardValue">0.0</div>
                        </div>
                        <div class="metric-row">
                            <div class="metric-label">Average Completion Time:</div>
                            <div class="metric-value" id="avgCompletionTimeValue">0 steps</div>
                        </div>
                        <div class="metric-row">
                            <div class="metric-label">Collision Rate:</div>
                            <div class="metric-value" id="collisionRateValue">0%</div>
                        </div>
                    </div>
                    
                    <div id="trajectoryVisualization" class="trajectory-vis">
                        <!-- Visualization of robot trajectories will be added here -->
                    </div>
                </div>
                <div class="loader" id="evaluationLoader"></div>
                <div class="status-message" id="evaluationStatus"></div>
            </div>
            
            <!-- NEW STEP 4: ANALYZE POLICY EFFECTIVENESS -->
            <div class="card step-container">
                <div class="step-number">4</div>
                <h2>Analyze Policy Effectiveness</h2>
                <p>Compare your selected policy against baseline algorithms to understand its relative performance.</p>
                
                <div class="form-group">
                    <label for="benchmarkModelSelect">Select Model to Analyze:</label>
                    <select id="benchmarkModelSelect" class="form-control">
                        <option value="">Select a model to analyze</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="numBenchmarkEpisodes">Number of Benchmark Episodes:</label>
                    <input type="number" id="numBenchmarkEpisodes" class="form-control" value="3" min="1" max="10">
                    <small class="text-muted">More episodes provide more accurate benchmarks but take longer to complete</small>
                </div>
                
                <div class="form-group">
                    <label>Compare Against:</label>
                    <div class="checkbox-group">
                        <label><input type="checkbox" id="compareRandom" checked> Random Policy</label>
                        <label><input type="checkbox" id="compareHeuristic" checked> Heuristic Policy</label>
                        <label><input type="checkbox" id="compareImitation" checked> Imitation Policy</label>
                    </div>
                </div>
                
                <button id="startBenchmarkBtn" class="btn btn-primary btn-lg">Run Benchmark Analysis</button>
                
                <div id="benchmarkStatusContainer" style="display: none;">
                    <h3>Benchmark Status:</h3>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress" id="benchmarkProgress"></div>
                        </div>
                        <div id="benchmarkProgressText">0%</div>
                    </div>
                    <div class="benchmark-info">
                        <div id="benchmarkSteps"></div>
                        <div id="benchmarkMessage"></div>
                    </div>
                </div>
                
                <div id="benchmarkResultsContainer" style="display: none;">
                    <h3>Benchmark Results:</h3>
                    
                    <div class="benchmark-metrics">
                        <h4>Performance Comparison:</h4>
                        <div class="benchmark-chart-container">
                            <img id="benchmarkMetricsChart" class="benchmark-chart" src="" alt="Metrics comparison chart">
                        </div>
                    </div>
                    
                    <div class="benchmark-radar">
                        <h4>Overall Performance Analysis:</h4>
                        <div class="benchmark-chart-container">
                            <img id="benchmarkRadarChart" class="benchmark-chart" src="" alt="Radar comparison chart">
                        </div>
                    </div>
                    
                    <div class="benchmark-summary">
                        <h4>Summary:</h4>
                        <div id="benchmarkSummaryText"></div>
                    </div>
                </div>
                
                <div class="loader" id="benchmarkLoader"></div>
                <div class="status-message" id="benchmarkStatus"></div>
            </div>
        </div>
    </div>
    
    <!-- Installation Modal -->
    <div class="modal fade" id="installationModal" tabindex="-1" aria-labelledby="installationModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="installationModalLabel">Aloha Environment Installation</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-info mb-4">
                        <strong>Simulation Mode Available!</strong>
                        <p>You can now use Simulation Mode with just MuJoCo installed (no Aloha required):</p>
                        <pre class="bg-dark text-light p-2 rounded mb-0">pip install "gymnasium[mujoco]" mujoco</pre>
                        <p class="mt-2 mb-0">After installing these packages, try evaluating again to use Simulation Mode.</p>
                    </div>
                
                    <p>For full Aloha environment evaluation, follow these installation steps:</p>
                    <div class="bg-light p-4 rounded mb-3">
                        <h6>Option 1 (Recommended): Use mujoco_py (more stable with gym)</h6>
                        <ol class="mb-3">
                            <li>Download MuJoCo 1.50 from <a href="https://www.roboti.us/download.html" target="_blank">https://www.roboti.us/download.html</a></li>
                            <li>Extract it to <code>~/.mujoco/mjpro150</code></li>
                            <li>Place your license key at <code>~/.mujoco/mjkey.txt</code> (get a free trial from roboti.us)</li>
                            <li>
                                Install dependencies:
                                <ul>
                                    <li>On Ubuntu: <code>apt install libgl1-mesa-dev libgl1-mesa-glx libglew-dev libosmesa6-dev</code></li>
                                    <li>On macOS: <code>brew install gcc cmake glew</code></li>
                                </ul>
                            </li>
                            <li>Set environment variables: <code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:~/.mujoco/mjpro150/bin</code></li>
                            <li>Install mujoco_py: <code>pip install mujoco_py==1.50.1.68</code></li>
                            <li>Install gym-aloha: <code>pip install gym-aloha</code></li>
                        </ol>

                        <h6>Option 2: Use newer MuJoCo (standalone)</h6>
                        <ol>
                            <li>Install MuJoCo: <code>pip install mujoco</code></li>
                            <li>Set environment variable: <code>export MUJOCO_PATH=/path/to/mujoco</code></li>
                            <li>Install gym-aloha: <code>pip install gym-aloha</code></li>
                        </ol>
                    </div>
                    <p class="mb-0">For more information, see:</p>
                    <ul>
                        <li><a href="https://github.com/openai/mujoco-py" target="_blank">https://github.com/openai/mujoco-py</a></li>
                        <li><a href="https://neptune.ai/blog/installing-mujoco-to-work-with-openai-gym-environments" target="_blank">Neptune.ai Guide to Installing MuJoCo</a></li>
                    </ul>
                    <div id="installationModalContent" style="display: none;"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#installationModalMac">Mac-Specific Instructions</button>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Mac Installation Modal -->
    <div class="modal fade" id="installationModalMac" tabindex="-1" aria-labelledby="installationModalMacLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="installationModalMacLabel">Installing MuJoCo on macOS</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <h5>Step-by-Step Installation for macOS</h5>
                    <ol class="mb-4">
                        <li>
                            <strong>Simple Option: Install MuJoCo for Simulation Mode</strong>
                            <p>For simulation mode only (recommended):</p>
                            <pre class="bg-dark text-light p-2 rounded">pip install "gymnasium[mujoco]" mujoco</pre>
                            <p>This is the simplest option and does not require a license key.</p>
                        </li>
                        <li>
                            <strong>Full Option: Install Aloha Environment</strong>
                            <p>For the complete Aloha environment:</p>
                        </li>
                        <li>
                            <strong>Download MuJoCo v1.50</strong>
                            <p>Visit <a href="https://www.roboti.us/download.html" target="_blank">https://www.roboti.us/download.html</a> and download the "mjpro150 osx" DMG file.</p>
                        </li>
                        <li>
                            <strong>Mount and Install MuJoCo</strong>
                            <p>Double-click the downloaded DMG file to mount it. You'll see the MuJoCo folder.</p>
                            <p>Create a <code>.mujoco</code> folder in your home directory:</p>
                            <pre class="bg-dark text-light p-2 rounded">mkdir ~/.mujoco</pre>
                            <p>Drag the <code>mjpro150</code> folder from the mounted DMG to <code>~/.mujoco/</code></p>
                        </li>
                        <li>
                            <strong>Get a License Key</strong>
                            <p>Visit <a href="https://www.roboti.us/license.html" target="_blank">https://www.roboti.us/license.html</a> to get a 30-day free trial license.</p>
                            <p>You'll receive an email with mjkey.txt. Save this file to <code>~/.mujoco/mjkey.txt</code></p>
                        </li>
                        <li>
                            <strong>Install Required Dependencies</strong>
                            <p>Install Homebrew if not already installed:</p>
                            <pre class="bg-dark text-light p-2 rounded">ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</pre>
                            <p>Install required packages:</p>
                            <pre class="bg-dark text-light p-2 rounded">brew install gcc cmake glew</pre>
                        </li>
                        <li>
                            <strong>Set Environment Variables</strong>
                            <p>Add these lines to your <code>~/.zshrc</code> or <code>~/.bash_profile</code>:</p>
                            <pre class="bg-dark text-light p-2 rounded">export MUJOCO_PY_MJPRO_PATH=~/.mujoco/mjpro150
export MUJOCO_PY_MJKEY_PATH=~/.mujoco/mjkey.txt
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:~/.mujoco/mjpro150/bin</pre>
                            <p>Apply the changes:</p>
                            <pre class="bg-dark text-light p-2 rounded">source ~/.zshrc</pre>
                            <p>Or:</p>
                            <pre class="bg-dark text-light p-2 rounded">source ~/.bash_profile</pre>
                        </li>
                        <li>
                            <strong>Install mujoco-py</strong>
                            <p>Install the correct version:</p>
                            <pre class="bg-dark text-light p-2 rounded">pip install lockfile
pip install mujoco-py==1.50.1.68</pre>
                        </li>
                        <li>
                            <strong>Install gym with MuJoCo support</strong>
                            <pre class="bg-dark text-light p-2 rounded">pip install gym[mujoco]</pre>
                        </li>
                        <li>
                            <strong>Finally, install gym-aloha</strong>
                            <pre class="bg-dark text-light p-2 rounded">pip install gym-aloha</pre>
                        </li>
                    </ol>
                    
                    <h5>Troubleshooting</h5>
                    <div class="alert alert-info">
                        <p><strong>For Apple Silicon (M1/M2) Macs:</strong> You might need additional steps:</p>
                        <pre class="bg-dark text-light p-2 rounded">brew install llvm
export CC="/usr/local/opt/llvm/bin/clang"
export CXX="/usr/local/opt/llvm/bin/clang++"
export LDFLAGS="-L/usr/local/opt/llvm/lib"
export CPPFLAGS="-I/usr/local/opt/llvm/include"</pre>
                        <p>For more details, see the <a href="https://github.com/openai/mujoco-py#troubleshooting" target="_blank">mujoco-py troubleshooting guide</a>.</p>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Global variables
        let currentImagePath = null;
        let detectedObjectsActions = null;
        let applicableDatasets = {};  // Object to store all applicable datasets with priorities
        let selectedDatasets = [];    // Array to store selected datasets for training
        let trainingStopped = false;
        
        // Flag to track when training has just finished
        window.justFinishedTraining = false;
        
        // Wait for DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize the application
            init();
        });
        
        // Helper functions
        function showLoader(id) {
            document.getElementById(id).style.display = 'block';
        }
        
        function hideLoader(id) {
            document.getElementById(id).style.display = 'none';
        }
        
        function showMessage(id, message, type) {
            const statusMessage = document.getElementById(id);
            statusMessage.textContent = message;
            statusMessage.className = 'status-message ' + type;
            statusMessage.style.display = 'block';
            
            // Auto-hide after 10 seconds if it's a success message
            if (type === 'success') {
                setTimeout(() => {
                    statusMessage.style.display = 'none';
                }, 10000);
            }
        }
        
        // Load models and history on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadModels();
            loadHistory();
            loadEvaluationHistory();
            updateEvaluateModelSelect();
            
            // Set up event listeners
            document.getElementById('uploadForm').addEventListener('submit', uploadImage);
            document.getElementById('detectBtn').addEventListener('click', detectObjects);
            
            // Debug: Check if the element exists
            console.log('testSelectionBtn exists:', !!document.getElementById('testSelectionBtn'));
            if (document.getElementById('testSelectionBtn')) {
                document.getElementById('testSelectionBtn').addEventListener('click', testDatasetSelection);
            }
            
            console.log('refreshModelsBtn exists:', !!document.getElementById('refreshModelsBtn'));
            if (document.getElementById('refreshModelsBtn')) {
                document.getElementById('refreshModelsBtn').addEventListener('click', function() {
                    loadModels();
                    updateEvaluateModelSelect();
                });
            }
            
            document.getElementById('editJsonBtn').addEventListener('click', toggleJsonEditor);
            document.getElementById('updateJsonBtn').addEventListener('click', updateObjectsActions);
            
            // Debug: Check if these buttons exist
            console.log('selectAllDatasetsBtn exists:', !!document.getElementById('selectAllDatasetsBtn'));
            console.log('deselectAllDatasetsBtn exists:', !!document.getElementById('deselectAllDatasetsBtn'));
            
            if (document.getElementById('selectAllDatasetsBtn')) {
                document.getElementById('selectAllDatasetsBtn').addEventListener('click', function() {
                    console.log('Select All button clicked');
                    selectAllDatasets();
                });
            }
            
            if (document.getElementById('deselectAllDatasetsBtn')) {
                document.getElementById('deselectAllDatasetsBtn').addEventListener('click', function() {
                    console.log('Deselect All button clicked');
                    deselectAllDatasets();
                });
            }
            
            // Debug: Check if the start training button exists
            console.log('startTrainingBtn exists:', !!document.getElementById('startTrainingBtn'));
            if (document.getElementById('startTrainingBtn')) {
                document.getElementById('startTrainingBtn').addEventListener('click', function() {
                    console.log('Start Training button clicked');
                    startTraining();
                });
            }
            
            document.getElementById('generateNameBtn').addEventListener('click', generateModelName);
            document.getElementById('startEvaluationBtn').addEventListener('click', startEvaluation);
            
            // Set up new benchmark event listeners
            document.getElementById('startBenchmarkBtn').addEventListener('click', startBenchmarkAnalysis);
            
            // Set a default model name on page load with current date/time
            generateModelName();
            
            // Add the installation modal to the document body
            document.body.insertAdjacentHTML('beforeend', installationModalHTML);
        });
        
        // Upload image
        function uploadImage(event) {
            event.preventDefault();
            
            const fileInput = document.getElementById('imageInput');
            if (!fileInput.files.length) {
                showMessage('uploadStatus', 'Please select an image file', 'error');
                return;
            }
            
            const formData = new FormData();
            formData.append('image', fileInput.files[0]);
            
            showLoader('uploadLoader');
            showMessage('uploadStatus', 'Uploading image...', 'info');
            
            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(result => {
                hideLoader('uploadLoader');
                
                if (result.success) {
                    showMessage('uploadStatus', 'Image uploaded successfully', 'success');
                    
                    // Store the image path for later use
                    currentImagePath = result.image_path;
                    
                    // Display image preview
                    document.getElementById('imagePreview').src = result.image_url;
                    document.getElementById('imagePreviewContainer').style.display = 'block';
                    
                    // Enable detect button
                    document.getElementById('detectBtn').disabled = false;
                    
                    // Reset detection and training
                    document.getElementById('detectionResult').style.display = 'none';
                    document.getElementById('trainingStatusContainer').style.display = 'none';
                    document.getElementById('trainingProgress').style.width = '0%';
                    document.getElementById('trainingProgressText').textContent = '0%';
                } else {
                    showMessage('uploadStatus', `Upload failed: ${result.error}`, 'error');
                }
            })
            .catch(error => {
                hideLoader('uploadLoader');
                showMessage('uploadStatus', `Error: ${error.message}`, 'error');
            });
        }
        
        // Detect objects
        function detectObjects() {
            console.log('detectObjects function called');
            if (!currentImagePath) {
                console.error('No image available for detection');
                showMessage('detectStatus', 'No image available for detection', 'error');
                return;
            }
            
            const customPrompt = document.getElementById('customPrompt').value;
            console.log('customPrompt:', customPrompt);
            
            showLoader('detectLoader');
            showMessage('detectStatus', 'Detecting objects...', 'info');
            
            fetch('/detect', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    image_path: currentImagePath,
                    prompt: customPrompt || null
                })
            })
            .then(response => {
                console.log('detect API status:', response.status);
                return response.json();
            })
            .then(result => {
                console.log('detect API response:', result);
                hideLoader('detectLoader');
                
                if (result.success) {
                    showMessage('detectStatus', 'Objects detected successfully', 'success');
                    
                    // Store the detected objects and actions
                    detectedObjectsActions = result.objects_actions;
                    console.log('Detected objects and actions:', detectedObjectsActions);
                    
                    // Display the JSON in the editor
                    document.getElementById('objectsActionsJson').value = JSON.stringify(detectedObjectsActions, null, 2);
                    
                    // Display the detected objects
                    displayDetectedObjects(result.objects_actions);
                    
                    // Show the detection result
                    document.getElementById('detectionResult').style.display = 'block';
                    
                    // List applicable datasets
                    listApplicableDatasets(detectedObjectsActions);
                } else {
                    console.error('Detection failed:', result.error);
                    showMessage('detectStatus', `Detection failed: ${result.error}`, 'error');
                }
            })
            .catch(error => {
                console.error('Error in detectObjects:', error);
                hideLoader('detectLoader');
                showMessage('detectStatus', `Error: ${error.message}`, 'error');
            });
        }
        
        // List applicable datasets
        function listApplicableDatasets(objectsActions) {
            console.log('listApplicableDatasets called with objectsActions:', objectsActions);
            showLoader('detectLoader');
            showMessage('detectStatus', 'Finding applicable datasets...', 'info');
            
            fetch('/test-selection', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    objects_actions: objectsActions
                })
            })
            .then(response => response.json())
            .then(result => {
                console.log('test-selection API response:', result);
                hideLoader('detectLoader');
                
                if (result.success) {
                    // Store all applicable datasets with priorities
                    // Note: Change the API response to include all sorted datasets with priorities
                    // For now, we'll extract dataset priorities from the 'mapping_details'
                    
                    // Clear previously selected datasets
                    console.log('Clearing applicableDatasets and selectedDatasets');
                    applicableDatasets = {};
                    selectedDatasets = [];
                    
                    // Get all unique datasets from the COMMON_OBJECT_DATASETS and ACTION_DATASETS
                    const allDatasets = new Set();
                    
                    // We'll simulate getting all applicable datasets with priorities
                    // In a real implementation, you'd get this from a proper API endpoint
                    const datasetPriorities = result.dataset_priorities || {};
                    console.log('datasetPriorities from API:', datasetPriorities);
                    
                    // If we have the priority scores in the response
                    for (const [dataset, priority] of Object.entries(datasetPriorities)) {
                        console.log('Adding dataset with priority:', dataset, priority);
                        applicableDatasets[dataset] = {
                            priority: priority,
                            matches: result.mapping_details[dataset] || ["General purpose dataset"]
                        };
                        allDatasets.add(dataset);
                    }
                    
                    // If we don't have explicit priority data, create some based on the order of selected datasets
                    if (Object.keys(applicableDatasets).length === 0) {
                        console.log('No explicit priority data, creating from selected_datasets');
                        // First, add the selected datasets
                        result.selected_datasets.forEach((dataset, index) => {
                            console.log('Adding selected dataset:', dataset, 'with priority:', result.selected_datasets.length - index);
                            applicableDatasets[dataset] = {
                                priority: result.selected_datasets.length - index,  // Reverse priority so first is highest
                                matches: result.mapping_details[dataset] || ["General purpose dataset"]
                            };
                            allDatasets.add(dataset);
                        });
                        
                        // Add some general fallback datasets (this would be handled by the real API)
                        const fallbackDatasets = [
                            "lerobot/metaworld_mt50", 
                            "lerobot/taco_play", 
                            "lerobot/berkeley_rpt",
                            "lerobot/ucsd_pick_and_place_dataset"
                        ];
                        
                        // Add fallback datasets not already in the list
                        fallbackDatasets.forEach(dataset => {
                            if (!applicableDatasets[dataset]) {
                                console.log('Adding fallback dataset:', dataset);
                                applicableDatasets[dataset] = {
                                    priority: 0.5,  // Low priority
                                    matches: ["General purpose dataset"]
                                };
                                allDatasets.add(dataset);
                            }
                        });
                    }
                    
                    console.log('Final applicableDatasets:', applicableDatasets);
                    
                    // Display datasets for selection
                    displayDatasetsForSelection(applicableDatasets);
                    
                    // Enable the start training button
                    console.log('Enabling startTrainingBtn');
                    document.getElementById('startTrainingBtn').disabled = false;
                } else {
                    console.error('Dataset selection failed:', result.error);
                    showMessage('detectStatus', `Dataset selection failed: ${result.error}`, 'error');
                }
            })
            .catch(error => {
                console.error('Error in listApplicableDatasets:', error);
                hideLoader('detectLoader');
                showMessage('detectStatus', `Error: ${error.message}`, 'error');
            });
        }
        
        // Display datasets for selection - improved to ensure the dataset-checkbox class is applied
        function displayDatasetsForSelection(datasets) {
            console.log('displayDatasetsForSelection called with datasets:', datasets);
            const container = document.getElementById('datasetSelectionList');
            
            if (!container) {
                console.error('datasetSelectionList container not found');
                return;
            }
            
            // Clear the container
            container.innerHTML = '';
            
            // Check if we have any datasets
            if (Object.keys(datasets).length === 0) {
                console.log('No datasets to display');
                container.innerHTML = '<div>No suitable datasets found</div>';
                return;
            }
            
            // Clear the selectedDatasets array before adding new ones
            console.log('Clearing selectedDatasets array');
            selectedDatasets = [];
            
            // Sort datasets by priority (highest first)
            const sortedDatasets = Object.entries(datasets).sort((a, b) => b[1].priority - a[1].priority);
            console.log('Sorted datasets:', sortedDatasets);
            
            // Add checkbox for each dataset
            sortedDatasets.forEach(([dataset, info]) => {
                console.log('Creating checkbox for dataset:', dataset);
                
                // Create container div for this dataset
                const datasetItem = document.createElement('div');
                datasetItem.className = 'dataset-checkbox-item';
                
                // Create checkbox input
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `dataset-${dataset.replace(/\//g, '-')}`;
                checkbox.value = dataset;
                checkbox.className = 'dataset-checkbox'; // Make sure this class is set
                
                // Auto-select datasets with high priority
                if (info.priority > 1) {
                    console.log('Auto-selecting dataset with high priority:', dataset);
                    checkbox.checked = true;
                    selectedDatasets.push(dataset);
                }
                
                // Add event listener to update selectedDatasets array
                checkbox.addEventListener('change', function() {
                    console.log('Checkbox changed for dataset:', dataset, 'New state:', this.checked);
                    if (this.checked) {
                        console.log('Adding dataset to selectedDatasets:', dataset);
                        
                        // Avoid duplicates
                        if (!selectedDatasets.includes(dataset)) {
                            selectedDatasets.push(dataset);
                        }
                    } else {
                        console.log('Removing dataset from selectedDatasets:', dataset);
                        const index = selectedDatasets.indexOf(dataset);
                        if (index > -1) {
                            selectedDatasets.splice(index, 1);
                        }
                    }
                    console.log('Updated selectedDatasets:', selectedDatasets);
                });
                
                // Create label for the checkbox
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.innerHTML = `<strong>${dataset}</strong> (Priority: ${info.priority.toFixed(1)})`;
                
                // Add checkbox and label to the item container
                datasetItem.appendChild(checkbox);
                datasetItem.appendChild(label);
                
                // Add description (matches) if available
                if (info.matches && info.matches.length > 0) {
                    const description = document.createElement('div');
                    description.className = 'dataset-description';
                    description.textContent = 'Matches: ' + info.matches.join(', ');
                    datasetItem.appendChild(description);
                }
                
                // Add the item to the main container
                container.appendChild(datasetItem);
            });
            
            console.log('Finished creating dataset checkboxes. Total:', sortedDatasets.length);
            console.log('Currently selected datasets:', selectedDatasets);
            
            // Enable the select all/deselect all buttons
            const selectAllBtn = document.getElementById('selectAllDatasetsBtn');
            const deselectAllBtn = document.getElementById('deselectAllDatasetsBtn');
            
            if (selectAllBtn) selectAllBtn.disabled = false;
            if (deselectAllBtn) deselectAllBtn.disabled = false;
        }
        
        // Select all datasets - improved implementation
        function selectAllDatasets() {
            console.log('selectAllDatasets function called');
            
            // Get the container element
            const container = document.getElementById('datasetSelectionList');
            if (!container) {
                console.error('datasetSelectionList container not found');
                return;
            }
            
            // Clear the selected datasets array
            selectedDatasets = [];
            
            // Get all checkbox elements with the dataset-checkbox class
            const checkboxes = container.querySelectorAll('.dataset-checkbox');
            console.log('Number of dataset checkboxes found:', checkboxes.length);
            
            if (checkboxes.length === 0) {
                console.warn('No dataset checkboxes found. Make sure they have the dataset-checkbox class.');
                return;
            }
            
            // Check all checkboxes and add their values to selectedDatasets
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                console.log('Setting checkbox to checked:', checkbox.value);
                selectedDatasets.push(checkbox.value);
            });
            
            console.log('Selected datasets after selectAll:', selectedDatasets);
        }
        
        // Deselect all datasets - improved implementation
        function deselectAllDatasets() {
            console.log('deselectAllDatasets function called');
            
            // Get the container element
            const container = document.getElementById('datasetSelectionList');
            if (!container) {
                console.error('datasetSelectionList container not found');
                return;
            }
            
            // Get all checkbox elements with the dataset-checkbox class
            const checkboxes = container.querySelectorAll('.dataset-checkbox');
            console.log('Number of dataset checkboxes found:', checkboxes.length);
            
            if (checkboxes.length === 0) {
                console.warn('No dataset checkboxes found. Make sure they have the dataset-checkbox class.');
                return;
            }
            
            // Uncheck all checkboxes
            checkboxes.forEach(checkbox => {
                console.log('Setting checkbox to unchecked:', checkbox.value);
                checkbox.checked = false;
            });
            
            // Clear the selected datasets array
            selectedDatasets = [];
            console.log('Selected datasets after deselectAll: []');
        }
        
        // Make sure the training status container is visible and properly configured
        function showTrainingStatus(model_name) {
            console.log('Showing training status for model:', model_name);
            
            // Get the training status container
            const container = document.getElementById('trainingStatusContainer');
            if (!container) {
                console.error('trainingStatusContainer not found');
                return;
            }
            
            // Set up the training status container
            container.style.display = 'block';
            document.getElementById('trainingProgress').style.width = '5%';
            document.getElementById('trainingProgressText').textContent = '5%';
            document.getElementById('trainingSteps').textContent = 'Preparing datasets...';
            document.getElementById('trainingMessage').textContent = '';
            
            // Set the model name if provided
            if (model_name) {
                document.getElementById('modelName').value = model_name;
            }
        }
        
        // Start training with selected datasets - improved with better model refreshing
        function startTraining() {
            console.log('startTraining function called');
            console.log('selectedDatasets:', selectedDatasets);
            
            // Check if we have any selected datasets
            if (selectedDatasets.length === 0) {
                console.log('No datasets selected');
                showMessage('detectStatus', 'Please select at least one dataset for training', 'error');
                return;
            }
            
            // Get the model name
            const modelName = document.getElementById('modelName').value || `robot_policy_${new Date().getTime()}`;
            console.log('modelName:', modelName);
            
            // Check for the fields we need
            const sampleLimitElement = document.getElementById('sampleLimit');
            const numEpochsElement = document.getElementById('numEpochs');
            
            console.log('sampleLimit element exists:', !!sampleLimitElement);
            console.log('numEpochs element exists:', !!numEpochsElement);
            
            // Get training parameters with defaults if elements don't exist
            const sampleLimit = sampleLimitElement ? parseInt(sampleLimitElement.value || 10000) : 10000;
            const numEpochs = numEpochsElement ? parseInt(numEpochsElement.value || 50) : 50;
            
            console.log('sampleLimit:', sampleLimit);
            console.log('numEpochs:', numEpochs);
            
            // Show loading indicators
            showLoader('detectLoader');
            showMessage('detectStatus', 'Starting training process...', 'info');
            
            // Show training status container
            showTrainingStatus(modelName);
            
            // Reset the training stopped flag
            trainingStopped = false;
            
            // Check if detectedObjectsActions exists
            if (!detectedObjectsActions) {
                console.error('No detected objects and actions available');
                showMessage('detectStatus', 'No detected objects and actions available. Please detect objects first.', 'error');
                hideLoader('detectLoader');
                return;
            }
            
            // Prepare the request data
            const requestData = {
                objects_actions: detectedObjectsActions,
                model_name: modelName,
                sample_limit: sampleLimit,
                num_epochs: numEpochs,
                batch_size: 32,
                learning_rate: 0.0001,
                selected_datasets: selectedDatasets  // Pass the selected datasets to the API
            };
            
            console.log('Sending training request with data:', requestData);
            
            // Make the API request
            fetch('/train', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestData)
            })
            .then(response => {
                console.log('Training API responded with status:', response.status);
                return response.json();
            })
            .then(result => {
                console.log('Training API response:', result);
                hideLoader('detectLoader');
                
                if (result.success) {
                    // Set a flag to indicate training just finished successfully
                    window.justFinishedTraining = true;
                    console.log('Set justFinishedTraining flag to true');
                    
                    showMessage('detectStatus', `Training completed successfully! Model saved at: ${result.model_path}`, 'success');
                    document.getElementById('trainingProgress').style.width = '100%';
                    document.getElementById('trainingProgressText').textContent = '100%';
                    document.getElementById('trainingSteps').textContent = 'Training completed';
                    document.getElementById('trainingMessage').textContent = `Model saved as ${modelName}`;
                    
                    // Give a short delay before refreshing the models to ensure the server has processed everything
                    setTimeout(() => {
                        console.log('Refreshing models after training');
                        
                        // Refresh models and history
                        loadModels();
                        loadHistory();
                        
                        // Also explicitly update the evaluation model dropdown with newly trained model
                        updateEvaluateModelSelect();
                        
                        // Additional safety check: Try explicitly selecting the new model
                        setTimeout(() => {
                            const evaluateSelect = document.getElementById('evaluateModelSelect');
                            if (evaluateSelect) {
                                // Try to find the option with the new model name
                                for (let i = 0; i < evaluateSelect.options.length; i++) {
                                    if (evaluateSelect.options[i].value === modelName) {
                                        evaluateSelect.selectedIndex = i;
                                        console.log('Explicitly selected newly created model in dropdown:', modelName);
                                        break;
                                    }
                                }
                            }
                        }, 300);
                    }, 500);
                } else {
                    console.error('Training failed:', result.error);
                    showMessage('detectStatus', `Training failed: ${result.error}`, 'error');
                    document.getElementById('trainingSteps').textContent = 'Training failed';
                    document.getElementById('trainingMessage').textContent = result.error;
                }
            })
            .catch(error => {
                console.error('Error during training:', error);
                hideLoader('detectLoader');
                showMessage('detectStatus', `Error: ${error.message}`, 'error');
                document.getElementById('trainingSteps').textContent = 'Error during training';
                document.getElementById('trainingMessage').textContent = error.message;
            });
            
            // Start polling for training progress
            simulateTrainingProgress();
        }
        
        // Simulate training progress
        function simulateTrainingProgress() {
            let progress = 5;
            const progressBar = document.getElementById('trainingProgress');
            const progressText = document.getElementById('trainingProgressText');
            const trainingSteps = document.getElementById('trainingSteps');
            
            // Start polling for training progress
            pollTrainingProgress();
        }
        
        // Poll for training progress from the server
        function pollTrainingProgress() {
            if (trainingStopped) {
                return;
            }
            
            const progressBar = document.getElementById('trainingProgress');
            const progressText = document.getElementById('trainingProgressText');
            const trainingSteps = document.getElementById('trainingSteps');
            const trainingMessage = document.getElementById('trainingMessage');
            
            fetch('/training-progress')
                .then(response => response.json())
                .then(data => {
                    // Update the progress bar and text
                    const progress = data.progress;
                    progressBar.style.width = `${progress}%`;
                    progressText.textContent = `${Math.round(progress)}%`;
                    
                    // Update the training steps message
                    if (data.message) {
                        trainingSteps.textContent = data.message;
                    }
                    
                    // If training is still in progress, poll again in 2 seconds
                    if (data.in_progress) {
                        setTimeout(pollTrainingProgress, 2000);
                    } else {
                        // Training finished or failed
                        if (progress === 100) {
                            // Set flag to indicate training just finished
                            window.justFinishedTraining = true;
                            console.log('Training completed via polling - set justFinishedTraining flag to true');
                            
                            trainingMessage.textContent = `Training completed successfully for model: ${data.model_name}`;
                            trainingMessage.className = 'success';
                        } else {
                            trainingMessage.textContent = data.message || 'Training failed';
                            trainingMessage.className = 'error';
                        }
                        
                        // Refresh models and history
                        loadModels();
                        loadHistory();
                        // Also update the evaluation model dropdown
                        updateEvaluateModelSelect();
                    }
                })
                .catch(error => {
                    console.error('Error polling for training progress:', error);
                    trainingMessage.textContent = `Error updating progress: ${error.message}`;
                    trainingMessage.className = 'error';
                    
                    // Try again in 5 seconds if there was an error
                    setTimeout(pollTrainingProgress, 5000);
                });
        }
        
        // Display detected objects
        function displayDetectedObjects(objectsActions) {
            const container = document.getElementById('detectedObjectsList');
            container.innerHTML = '';
            
            for (const [object, actions] of Object.entries(objectsActions)) {
                const objectElement = document.createElement('div');
                objectElement.className = 'detected-object';
                objectElement.textContent = object;
                container.appendChild(objectElement);
                
                const actionsList = document.createElement('ul');
                actionsList.className = 'actions-list';
                
                actions.forEach(action => {
                    const actionItem = document.createElement('li');
                    actionItem.textContent = action;
                    actionsList.appendChild(actionItem);
                });
                
                container.appendChild(actionsList);
            }
        }
        
        // Toggle JSON editor
        function toggleJsonEditor() {
            const jsonEditor = document.getElementById('jsonEditorContainer');
            jsonEditor.style.display = jsonEditor.style.display === 'none' ? 'block' : 'none';
        }
        
        // Update objects and actions from JSON editor
        function updateObjectsActions() {
            try {
                const jsonText = document.getElementById('objectsActionsJson').value;
                detectedObjectsActions = JSON.parse(jsonText);
                
                displayDetectedObjects(detectedObjectsActions);
                showMessage('detectStatus', 'Objects and actions updated successfully', 'success');
                
                // Hide the JSON editor
                document.getElementById('jsonEditorContainer').style.display = 'none';
            } catch (e) {
                showMessage('detectStatus', `Invalid JSON format: ${e.message}`, 'error');
            }
        }
        
        // Test dataset selection
        function testDatasetSelection() {
            try {
                const objectsActions = JSON.parse(document.getElementById('testObjectsActions').value);
                
                showLoader('testLoader');
                
                fetch('/test-selection', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        objects_actions: objectsActions
                    })
                })
                .then(response => response.json())
                .then(result => {
                    hideLoader('testLoader');
                    
                    if (result.success) {
                        document.getElementById('selectedDatasetsCode').textContent = JSON.stringify(result.selected_datasets, null, 2);
                        document.getElementById('testSelectionResult').style.display = 'block';
                    } else {
                        showMessage('testStatus', `Dataset selection test failed: ${result.error}`, 'error');
                    }
                })
                .catch(error => {
                    hideLoader('testLoader');
                    showMessage('testStatus', `Error: ${error.message}`, 'error');
                });
            } catch (e) {
                showMessage('testStatus', `Invalid JSON format: ${e.message}`, 'error');
            }
        }
        
        // Load available models - improved with better error handling and sorting
        function loadModels() {
            console.log('loadModels called');
            
            // Get models from the server with cache-busting parameter to ensure fresh data
            const timestamp = new Date().getTime();
            fetch(`/models?_=${timestamp}`)
                .then(response => {
                    console.log('Models API status:', response.status);
                    return response.json();
                })
                .then(models => {
                    console.log('Retrieved models:', models);
                    const modelsList = document.getElementById('modelsList');
                    
                    if (!modelsList) {
                        console.error('modelsList element not found');
                        return;
                    }
                    
                    if (!models || !models.length) {
                        console.warn('No models available');
                        modelsList.innerHTML = '<tr><td colspan="3">No models available</td></tr>';
                        return;
                    }
                    
                    // Sort models by creation time (newest first)
                    models.sort((a, b) => new Date(b.created) - new Date(a.created));
                    
                    modelsList.innerHTML = '';
                    
                    models.forEach(model => {
                        const row = document.createElement('tr');
                        
                        // Format date for better readability
                        const created = new Date(model.created);
                        const createdStr = created.toLocaleString();
                        
                        row.innerHTML = `
                            <td>${model.name}</td>
                            <td>${model.size_mb} MB</td>
                            <td>${createdStr}</td>
                        `;
                        
                        modelsList.appendChild(row);
                    });
                    
                    // Also update the evaluation model dropdown
                    updateEvaluateModelSelect();
                })
                .catch(error => {
                    console.error('Error loading models:', error);
                    const modelsList = document.getElementById('modelsList');
                    if (modelsList) {
                        modelsList.innerHTML = '<tr><td colspan="3">Error loading models: ' + error.message + '</td></tr>';
                    }
                });
        }
        
        // Load training history
        function loadHistory() {
            fetch('/history')
                .then(response => response.json())
                .then(history => {
                    const historyList = document.getElementById('historyList');
                    
                    if (!history.length) {
                        historyList.innerHTML = '<tr><td colspan="3">No training history available</td></tr>';
                        return;
                    }
                    
                    historyList.innerHTML = '';
                    
                    history.forEach(entry => {
                        const row = document.createElement('tr');
                        
                        // Format date for better readability
                        const date = new Date(entry.date);
                        const dateStr = date.toLocaleString();
                        
                        row.innerHTML = `
                            <td>${entry.id}</td>
                            <td>${dateStr}</td>
                            <td>${entry.model_name}</td>
                        `;
                        
                        historyList.appendChild(row);
                    });
                })
                .catch(error => {
                    console.error('Error loading history:', error);
                });
        }
        
        // Generate a unique model name with current date and time
        function generateModelName() {
            const date = new Date();
            const dateStr = date.toISOString().replace(/[T:.-]/g, '_').substring(0, 19);
            const objects = detectedObjectsActions ? Object.keys(detectedObjectsActions).slice(0, 2).join('_') : 'robot';
            const modelName = `${objects}_policy_${dateStr}`;
            document.getElementById('modelName').value = modelName;
        }
        
        // Evaluate policy
        function startEvaluation() {
            const modelName = document.getElementById('evaluateModelSelect').value;
            const numEpisodes = parseInt(document.getElementById('numEvaluationEpisodes').value || 10);
            
            if (!modelName) {
                showMessage('evaluationStatus', 'Please select a model to evaluate', 'error');
                return;
            }
            
            showLoader('evaluationLoader');
            showMessage('evaluationStatus', 'Starting evaluation...', 'info');
            
            // Reset previous results
            document.getElementById('evaluationResultsContainer').style.display = 'none';
            
            // Show evaluation status container
            document.getElementById('evaluationStatusContainer').style.display = 'block';
            document.getElementById('evaluationSteps').textContent = 'Initializing evaluation...';
            document.getElementById('evaluationMessage').textContent = '';
            document.getElementById('evaluationProgress').style.width = '5%';
            document.getElementById('evaluationProgressText').textContent = '5%';
            
            fetch('/evaluate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model_name: modelName,
                    num_episodes: numEpisodes
                })
            })
            .then(response => response.json())
            .then(result => {
                hideLoader('evaluationLoader');
                
                if (result.success) {
                    showMessage('evaluationStatus', 'Evaluation completed successfully!', 'success');
                    
                    // Display evaluation results
                    displayEvaluationResults(result.results);
                    
                    // Refresh evaluation history
                    loadEvaluationHistory();
                } else {
                    showMessage('evaluationStatus', `Evaluation failed: ${result.error}`, 'error');
                    document.getElementById('evaluationSteps').textContent = 'Evaluation failed';
                    document.getElementById('evaluationMessage').textContent = result.error;
                }
            })
            .catch(error => {
                hideLoader('evaluationLoader');
                showMessage('evaluationStatus', `Error: ${error.message}`, 'error');
                document.getElementById('evaluationSteps').textContent = 'Error during evaluation';
                document.getElementById('evaluationMessage').textContent = error.message;
            });
            
            // Start polling for evaluation progress
            pollEvaluationProgress();
        }
        
        // Poll for evaluation progress
        function pollEvaluationProgress() {
            const progressBar = document.getElementById('evaluationProgress');
            const progressText = document.getElementById('evaluationProgressText');
            const evaluationSteps = document.getElementById('evaluationSteps');
            const evaluationMessage = document.getElementById('evaluationMessage');
            
            fetch('/evaluation-progress')
                .then(response => response.json())
                .then(data => {
                    // Update the progress bar and text
                    const progress = data.progress;
                    progressBar.style.width = `${progress}%`;
                    progressText.textContent = `${Math.round(progress)}%`;
                    
                    // Update the evaluation steps message
                    if (data.message) {
                        evaluationSteps.textContent = data.message;
                    }
                    
                    // If evaluation is still in progress, poll again in 2 seconds
                    if (data.in_progress) {
                        setTimeout(pollEvaluationProgress, 2000);
                    } else if (progress > 0) {
                        // Evaluation finished or failed
                        evaluationMessage.textContent = data.message || '';
                        
                        // Check if we have results to display
                        if (data.results) {
                            // Pass the results object which contains success, success_rate etc.
                            displayEvaluationResults(data.results);
                        } else {
                            // Create a simple results object with success status
                            displayEvaluationResults({
                                success: data.success === true,
                                success_rate: data.success_rate || 0,
                                avg_reward: data.avg_reward || 0,
                                avg_completion_time: data.step || 0,
                                collision_rate: 0,
                                error: data.error || 'Evaluation completed but no results available.'
                            });
                        }
                    }
                })
                .catch(error => {
                    console.error('Error polling for evaluation progress:', error);
                    setTimeout(pollEvaluationProgress, 5000);
                });
        }
        
        // Display evaluation results
        function displayEvaluationResults(results) {
            // Show the results container
            document.getElementById('evaluationResultsContainer').style.display = 'block';
            
            // Ensure results is an object
            results = results || {};
            
            // Check if this is an error result
            if (results.success === false) {
                // Check if this is a specific installation error
                if (results.installation_required) {
                    // Show installation instructions modal
                    document.getElementById('evaluationStatus').innerHTML = `
                        <div class="alert alert-warning">
                            <strong>Aloha Environment Required:</strong> 
                            <p>The evaluation requires the Aloha environment to be installed.</p>
                            <p>Click <a href="#" data-bs-toggle="modal" data-bs-target="#installationModal">here</a> to see installation instructions.</p>
                        </div>`;
                    
                    // Show detailed error message if available
                    const installationContent = document.getElementById('installationModalContent');
                    if (results.error && results.error.includes("Failed to import")) {
                        installationContent.style.display = "block";
                        installationContent.innerHTML = `
                            <div class="mt-4 pt-3 border-top">
                                <h6>Error Details:</h6>
                                <div class="bg-dark text-light p-3 rounded">
                                    <pre class="mb-0">${results.error.replace(/\n/g, '<br>')}</pre>
                                </div>
                            </div>`;
                    } else {
                        installationContent.style.display = "none";
                    }
                    
                    // Show the modal
                    const installationModal = new bootstrap.Modal(document.getElementById('installationModal'));
                    installationModal.show();
                } else {
                    // Standard error message
                    document.getElementById('evaluationStatus').innerHTML = `<div class="alert alert-danger">${results.error || 'Unknown error during evaluation'}</div>`;
                }
                return;
            }
            
            // Check if this is a simulated evaluation
            if (results.is_simulated) {
                document.getElementById('evaluationStatus').innerHTML = `
                    <div class="alert alert-info">
                        <strong>Simulation Mode:</strong> 
                        <p>${results.simulation_notice || "Evaluation was performed using a simulated environment instead of Aloha."}</p>
                        <p>The results may not accurately reflect performance on the real Aloha environment.</p>
                    </div>`;
            } else if (results.used_trained_model === false) {
                document.getElementById('evaluationStatus').innerHTML = `
                    <div class="alert alert-warning">
                        <strong>Note:</strong> 
                        <p>Evaluation was performed using a dummy policy because the trained model could not be loaded.</p>
                        <p>The results may not accurately reflect the actual trained model performance.</p>
                    </div>`;
            } else {
                document.getElementById('evaluationStatus').innerHTML = '';
            }
            
            // Update metric values with safe defaults
            document.getElementById('successRateValue').textContent = `${((results.success_rate || 0) * 100).toFixed(1)}%`;
            document.getElementById('avgRewardValue').textContent = (results.avg_reward || 0).toFixed(2);
            document.getElementById('avgCompletionTimeValue').textContent = `${Math.round(results.avg_completion_time || 0)} steps`;
            document.getElementById('collisionRateValue').textContent = `${((results.collision_rate || 0) * 100).toFixed(1)}%`;
            
            // If we have trajectory data, visualize it
            if (results.trajectories && results.trajectories.length > 0) {
                visualizeTrajectories(results.trajectories);
            } else {
                // Create simple visualization showing a dummy successful trajectory
                const vis = document.getElementById('trajectoryVisualization');
                vis.innerHTML = `
                    <div style="text-align: center; padding: 20px;">
                        <h4>Simulated Trajectory</h4>
                        <svg width="300" height="200" style="background: #f8f9fa; border: 1px solid #ddd;">
                            <circle cx="50" cy="100" r="6" fill="green"></circle>
                            <path d="M 50 100 C 100 50, 200 150, 250 100" stroke="${results.used_trained_model ? '#3498db' : '#95a5a6'}" stroke-width="3" fill="none"></path>
                            <circle cx="250" cy="100" r="6" fill="red"></circle>
                            <text x="150" y="180" text-anchor="middle" font-size="12">${results.used_trained_model ? 'Trained Policy Simulation' : 'Dummy Policy Simulation'}</text>
                        </svg>
                        <p style="margin-top: 10px; color: #666;">
                            ${results.is_simulated ? 'This is a simulated evaluation. ' : ''}
                            ${results.simulation_notice || ''}
                        </p>
                    </div>
                `;
            }
        }
        
        // Load evaluation history
        function loadEvaluationHistory() {
            fetch('/evaluation-history')
                .then(response => response.json())
                .then(history => {
                    const historyList = document.getElementById('evaluationHistoryList');
                    
                    if (!history.length) {
                        historyList.innerHTML = '<tr><td colspan="4">No evaluation history available</td></tr>';
                        return;
                    }
                    
                    historyList.innerHTML = '';
                    
                    history.forEach(entry => {
                        const row = document.createElement('tr');
                        
                        // Format date for better readability
                        const date = new Date(entry.date);
                        const dateStr = date.toLocaleString();
                        
                        row.innerHTML = `
                            <td>${entry.id}</td>
                            <td>${dateStr}</td>
                            <td>${entry.model_name}</td>
                            <td>${(entry.success_rate * 100).toFixed(1)}%</td>
                        `;
                        
                        historyList.appendChild(row);
                    });
                })
                .catch(error => {
                    console.error('Error loading evaluation history:', error);
                });
        }
        
        // Update models dropdown for evaluation - improved with debugging
        function updateEvaluateModelSelect() {
            console.log('updateEvaluateModelSelect called');
            
            const evaluateSelect = document.getElementById('evaluateModelSelect');
            const benchmarkSelect = document.getElementById('benchmarkModelSelect');
            
            if (!evaluateSelect) {
                console.error('evaluateModelSelect element not found');
                return;
            }
            
            if (!benchmarkSelect) {
                console.warn('benchmarkModelSelect element not found');
                // Continue with just the evaluateSelect
            }
            
            console.log('Current evaluateSelect options:', evaluateSelect.options.length);
            
            // Store the currently selected model name before clearing
            const previouslySelectedModel = evaluateSelect.value;
            console.log('Previously selected model:', previouslySelectedModel);
            
            // Clear existing options except the first one
            while (evaluateSelect.options.length > 1) {
                evaluateSelect.remove(1);
            }
            
            // Clear benchmark options except the first one (if it exists)
            if (benchmarkSelect) {
                while (benchmarkSelect.options.length > 1) {
                    benchmarkSelect.remove(1);
                }
            }
            
            console.log('After clearing, evaluateSelect options:', evaluateSelect.options.length);
            
            // Get models from the server with cache-busting parameter to ensure fresh data
            const timestamp = new Date().getTime();
            console.log(`Fetching models with URL: /models?_=${timestamp}`);
            
            fetch(`/models?_=${timestamp}`)
                .then(response => {
                    console.log('Models API response status:', response.status);
                    console.log('Models API response headers:', JSON.stringify([...response.headers.entries()]));
                    if (!response.ok) {
                        throw new Error(`Server responded with status: ${response.status}`);
                    }
                    return response.text().then(text => {
                        console.log('Raw response text:', text);
                        try {
                            return JSON.parse(text);
                        } catch (e) {
                            console.error('Failed to parse JSON:', e);
                            console.error('Response text was:', text);
                            throw new Error('Invalid JSON response');
                        }
                    });
                })
                .then(models => {
                    console.log('Retrieved models for dropdown (parsed JSON):', models);
                    
                    if (!models) {
                        console.error('Models is null or undefined');
                        return;
                    }
                    
                    if (!Array.isArray(models)) {
                        console.error('Models is not an array:', typeof models, models);
                        return;
                    }
                    
                    if (models.length === 0) {
                        console.warn('No models returned from server (empty array)');
                        return;
                    }
                    
                    // Sort models by creation time (newest first)
                    models.sort((a, b) => new Date(b.created) - new Date(a.created));
                    
                    let mostRecentModelName = models.length > 0 ? models[0].name : '';
                    console.log('Most recent model name:', mostRecentModelName);
                    
                    // Track if we found the previously selected model in the new list
                    let foundPreviouslySelected = false;
                    
                    models.forEach(model => {
                        console.log('Adding model to dropdown:', model.name);
                        
                        // Add to evaluation dropdown
                        const evalOption = document.createElement('option');
                        evalOption.value = model.name;
                        evalOption.textContent = model.name;
                        evaluateSelect.appendChild(evalOption);
                        
                        // Check if this was the previously selected model
                        if (model.name === previouslySelectedModel) {
                            foundPreviouslySelected = true;
                        }
                        
                        // Add to benchmark dropdown if it exists
                        if (benchmarkSelect) {
                            const benchOption = document.createElement('option');
                            benchOption.value = model.name;
                            benchOption.textContent = model.name;
                            benchmarkSelect.appendChild(benchOption);
                        }
                    });
                    
                    console.log('After adding models, evaluateSelect options:', evaluateSelect.options.length);
                    
                    // Determine which model to select
                    if (models.length > 0) {
                        // If we came from a training operation, select the most recent model (first in the sorted list)
                        // Otherwise, try to keep the previously selected model if it still exists
                        if (window.justFinishedTraining) {
                            console.log('Training just finished, selecting most recent model:', mostRecentModelName);
                            evaluateSelect.value = mostRecentModelName;
                            window.justFinishedTraining = false; // Reset the flag
                        } else if (foundPreviouslySelected && previouslySelectedModel) {
                            console.log('Restoring previously selected model:', previouslySelectedModel);
                            evaluateSelect.value = previouslySelectedModel;
                        } else {
                            console.log('Selecting most recent model:', mostRecentModelName);
                            evaluateSelect.value = mostRecentModelName;
                        }
                        
                        // Also update benchmark select if it exists
                        if (benchmarkSelect) {
                            benchmarkSelect.value = evaluateSelect.value;
                        }
                        
                        console.log('Final selected value:', evaluateSelect.value);
                    }
                })
                .catch(error => {
                    console.error('Error loading models for selection:', error);
                    
                    // Try an alternative approach - direct XHR request
                    console.log('Attempting alternative XHR request for models');
                    const xhr = new XMLHttpRequest();
                    xhr.open('GET', `/models?_=${new Date().getTime()}`);
                    xhr.onload = function() {
                        console.log('XHR status:', xhr.status);
                        console.log('XHR response text:', xhr.responseText);
                        if (xhr.status === 200) {
                            try {
                                const xhrModels = JSON.parse(xhr.responseText);
                                console.log('XHR models:', xhrModels);
                                // Process the models here if needed
                            } catch (e) {
                                console.error('Failed to parse XHR JSON:', e);
                            }
                        }
                    };
                    xhr.onerror = function() {
                        console.error('XHR request failed');
                    };
                    xhr.send();
                });
        }

        function visualizeTrajectories(trajectories) {
            const container = document.getElementById('trajectoryVisualization');
            container.innerHTML = ''; // Clear previous visualizations
            
            // For each trajectory, create a visualization
            trajectories.forEach((trajectory, index) => {
                // Create a container for this trajectory
                const trajectoryDiv = document.createElement('div');
                trajectoryDiv.className = 'trajectory-container';
                trajectoryDiv.style.marginBottom = '30px';
                
                // Add header with episode info
                const header = document.createElement('h4');
                header.textContent = `Episode ${trajectory.episode}: ${trajectory.success ? 'Success' : 'Failure'}`;
                header.style.color = trajectory.success ? '#2ecc71' : '#e74c3c';
                trajectoryDiv.appendChild(header);
                
                // Create SVG for visualization
                const svgWidth = trajectory.env_width || 600;
                const svgHeight = trajectory.env_height || 400;
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', svgWidth);
                svg.setAttribute('height', svgHeight);
                svg.style.border = '1px solid #ccc';
                svg.style.background = '#f9f9f9';
                svg.style.borderRadius = '5px';
                svg.style.margin = '10px 0';
                
                // Add obstacles
                if (trajectory.obstacles) {
                    trajectory.obstacles.forEach((obstacle) => {
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', obstacle.x);
                        circle.setAttribute('cy', obstacle.y);
                        circle.setAttribute('r', obstacle.radius);
                        circle.setAttribute('fill', 'rgba(180, 180, 180, 0.6)');
                        circle.setAttribute('stroke', '#888');
                        circle.setAttribute('stroke-width', '1');
                        svg.appendChild(circle);
                    });
                }
                
                // Draw path from waypoints
                if (trajectory.waypoints && trajectory.waypoints.length > 0) {
                    // Create path element
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    
                    // Generate path data
                    let pathData = `M ${trajectory.waypoints[0].x} ${trajectory.waypoints[0].y}`;
                    
                    for (let i = 1; i < trajectory.waypoints.length; i++) {
                        pathData += ` L ${trajectory.waypoints[i].x} ${trajectory.waypoints[i].y}`;
                    }
                    
                    path.setAttribute('d', pathData);
                    path.setAttribute('stroke', trajectory.success ? '#2ecc71' : '#e74c3c');
                    path.setAttribute('stroke-width', '3');
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke-linecap', 'round');
                    path.setAttribute('stroke-linejoin', 'round');
                    
                    // Add animation effect
                    const pathLength = path.getTotalLength ? path.getTotalLength() : 1000;
                    path.style.strokeDasharray = pathLength;
                    path.style.strokeDashoffset = pathLength;
                    path.style.animation = `drawPath 2s ease-in-out forwards`;
                    
                    svg.appendChild(path);
                    
                    // Add start and goal markers
                    const startPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    startPoint.setAttribute('cx', trajectory.start.x);
                    startPoint.setAttribute('cy', trajectory.start.y);
                    startPoint.setAttribute('r', '8');
                    startPoint.setAttribute('fill', '#3498db');
                    startPoint.setAttribute('stroke', '#2980b9');
                    startPoint.setAttribute('stroke-width', '2');
                    svg.appendChild(startPoint);
                    
                    // Add "Start" label
                    const startLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    startLabel.setAttribute('x', trajectory.start.x);
                    startLabel.setAttribute('y', trajectory.start.y - 15);
                    startLabel.setAttribute('text-anchor', 'middle');
                    startLabel.textContent = 'Start';
                    startLabel.style.fontSize = '12px';
                    startLabel.style.fontWeight = 'bold';
                    svg.appendChild(startLabel);
                    
                    const goalPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    goalPoint.setAttribute('cx', trajectory.goal.x);
                    goalPoint.setAttribute('cy', trajectory.goal.y);
                    goalPoint.setAttribute('r', '8');
                    goalPoint.setAttribute('fill', '#e74c3c');
                    goalPoint.setAttribute('stroke', '#c0392b');
                    goalPoint.setAttribute('stroke-width', '2');
                    svg.appendChild(goalPoint);
                    
                    // Add "Goal" label
                    const goalLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    goalLabel.setAttribute('x', trajectory.goal.x);
                    goalLabel.setAttribute('y', trajectory.goal.y - 15);
                    goalLabel.setAttribute('text-anchor', 'middle');
                    goalLabel.textContent = 'Goal';
                    goalLabel.style.fontSize = '12px';
                    goalLabel.style.fontWeight = 'bold';
                    svg.appendChild(goalLabel);
                }
                
                trajectoryDiv.appendChild(svg);
                container.appendChild(trajectoryDiv);
            });
            
            // Add CSS animation for path drawing
            const style = document.createElement('style');
            style.textContent = `
                @keyframes drawPath {
                    to {
                        stroke-dashoffset: 0;
                    }
                }
            `;
            document.head.appendChild(style);
        }
        
        // NEW: Run benchmark analysis
        function startBenchmarkAnalysis() {
            console.log('startBenchmarkAnalysis called');
            
            // Get form values
            const modelName = document.getElementById('benchmarkModelSelect').value;
            const numEpisodes = parseInt(document.getElementById('numBenchmarkEpisodes').value || '3');
            
            // Get baseline selections from checkboxes
            const selectedBaselines = [];
            if (document.getElementById('compareRandom').checked) selectedBaselines.push('random');
            if (document.getElementById('compareHeuristic').checked) selectedBaselines.push('heuristic');
            if (document.getElementById('compareImitation').checked) selectedBaselines.push('imitation');
            
            console.log('Model name:', modelName);
            console.log('Number of episodes:', numEpisodes);
            console.log('Selected baselines:', selectedBaselines);
            
            // Validate form
            if (!modelName) {
                showMessage('benchmarkStatus', 'Please select a model to analyze', 'error');
                return;
            }
            
            // Prepare request data - Changed parameter names to match backend expectations
            const requestData = {
                model: modelName,                 // Changed from model_name to model
                episodes: numEpisodes,            // Changed from num_episodes to episodes
                baselines: true,                  // Whether to include baselines at all
                baseline_list: selectedBaselines  // List of specific baselines to include
            };
            
            console.log('Starting benchmark with data:', requestData);
            
            // Show loading indicator and status container
            showLoader('benchmarkLoader');
            document.getElementById('benchmarkStatusContainer').style.display = 'block';
            document.getElementById('benchmarkResultsContainer').style.display = 'none';
            
            // Reset progress bar and status
            document.getElementById('benchmarkProgress').style.width = '0%';
            document.getElementById('benchmarkProgressText').textContent = '0%';
            document.getElementById('benchmarkSteps').textContent = 'Initializing benchmark...';
            document.getElementById('benchmarkMessage').textContent = '';
            
            // Send request to start benchmark
            fetch('/run-benchmark', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestData)
            })
            .then(response => {
                console.log('Benchmark API response status:', response.status);
                return response.json();
            })
            .then(data => {
                console.log('Benchmark API response:', data);
                
                if (data.success) {
                    showMessage('benchmarkStatus', 'Benchmark started, monitoring progress...', 'info');
                    
                    // Start polling for progress
                    setTimeout(pollBenchmarkProgress, 1000);
                } else {
                    hideLoader('benchmarkLoader');
                    showMessage('benchmarkStatus', `Failed to start benchmark: ${data.error}`, 'error');
                }
            })
            .catch(error => {
                console.error('Error starting benchmark:', error);
                hideLoader('benchmarkLoader');
                showMessage('benchmarkStatus', `Error: ${error.message}`, 'error');
            });
        }

        // Poll for benchmark progress
        function pollBenchmarkProgress() {
            fetch('/benchmark-progress')
                .then(response => response.json())
                .then(data => {
                    console.log('Benchmark progress update:', data);
                    
                    // Update progress bar and text
                    const progress = data.progress || 0;
                    document.getElementById('benchmarkProgress').style.width = `${progress}%`;
                    document.getElementById('benchmarkProgressText').textContent = `${progress}%`;
                    
                    // Update status message
                    if (data.message) {
                        document.getElementById('benchmarkSteps').textContent = data.message;
                    }
                    
                    // If there's an error, show it
                    if (data.error) {
                        document.getElementById('benchmarkMessage').textContent = data.error;
                        document.getElementById('benchmarkMessage').className = 'error';
                    }
                    
                    // Check if benchmark is complete
                    if (!data.in_progress) {
                        hideLoader('benchmarkLoader');
                        
                        if (progress === 100) {
                            document.getElementById('benchmarkMessage').textContent = 'Benchmark completed successfully!';
                            document.getElementById('benchmarkMessage').className = 'success';
                            
                            // Handle results
                            handleBenchmarkResults(data);
                        } else {
                            document.getElementById('benchmarkMessage').textContent = data.error || 'Benchmark failed';
                            document.getElementById('benchmarkMessage').className = 'error';
                        }
                        
                        return; // Stop polling
                    }
                    
                    // Continue polling if benchmark is still in progress
                    setTimeout(pollBenchmarkProgress, 1000);
                })
                .catch(error => {
                    console.error('Error polling benchmark progress:', error);
                    document.getElementById('benchmarkMessage').textContent = `Error updating progress: ${error.message}`;
                    document.getElementById('benchmarkMessage').className = 'error';
                    
                    // Try again after a delay
                    setTimeout(pollBenchmarkProgress, 2000);
                });
        }

        // Handle benchmark results
        function handleBenchmarkResults(data) {
            // If we have chart paths directly in the progress data
            if (data.metrics_chart && data.radar_chart) {
                displayBenchmarkCharts(data.metrics_chart, data.radar_chart);
                return;
            }
            
            // Otherwise, try to get results from results file
            if (data.results_file) {
                fetch(`/benchmark-results?file=${data.results_file}`)
                    .then(response => response.json())
                    .then(results => {
                        if (results.metrics_chart && results.radar_chart) {
                            displayBenchmarkCharts(results.metrics_chart, results.radar_chart);
                            
                            // Display summary if available
                            if (results.summary) {
                                document.getElementById('benchmarkSummaryText').innerHTML = results.summary;
                            }
                        } else {
                            document.getElementById('benchmarkMessage').textContent = 'Benchmark completed but no charts were generated';
                            document.getElementById('benchmarkMessage').className = 'warning';
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching benchmark results:', error);
                        document.getElementById('benchmarkMessage').textContent = `Error loading results: ${error.message}`;
                        document.getElementById('benchmarkMessage').className = 'error';
                    });
            }
        }

        // Display benchmark charts
        function displayBenchmarkCharts(metricsChartUrl, radarChartUrl) {
            const resultsContainer = document.getElementById('benchmarkResultsContainer');
            resultsContainer.style.display = 'block';
            
            // Set chart image sources
            document.getElementById('benchmarkMetricsChart').src = metricsChartUrl;
            document.getElementById('benchmarkRadarChart').src = radarChartUrl;
        }
    </script>
</body>
</html> 